// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates contributors.go. It can be invoked by running
// go generate

package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
	"time"
)

type inputInfo struct {
	Timestamp    time.Time
	FileName     string
	VariableName string
	Values       []string
}

var packageTemplateText = `// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from:
// {{ .FileName }}

package input

var {{ .VariableName }}Values = []int{ {{ StringsJoin .Values ", " }} }

`

var packageTemplate = template.Must(template.New("").Funcs(template.FuncMap{"StringsJoin": strings.Join}).Parse(packageTemplateText))

var inputTemplateText = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

func {{ .VariableName | Title }}() []int {
	return {{ .VariableName }}Values
}

`
var inputTemplate = template.Must(template.New("").Funcs(template.FuncMap{"Title": strings.Title}).Parse(inputTemplateText))

func main() {

	inputDirs := listInputDirectory()

	inputInfos := parseInputFiles(inputDirs)

	generateCodeForInput(inputInfos)
}

func listInputDirectory() ([]os.FileInfo) {
	inputDirs, er := ioutil.ReadDir("../../input")
	handleError(er)
	return inputDirs
}

func handleError(er error) {
	if er != nil {
		fmt.Println(er)
		os.Exit(1)
	}
}

func parseInputFiles(inputDirs []os.FileInfo) []inputInfo {
	infos := make([]inputInfo, len(inputDirs))

	for i, inputDir := range inputDirs {

		inputFile, er := os.Open(fmt.Sprintf("../../input/%v/input.txt", inputDir.Name()))

		handleError(er)

		defer inputFile.Close()

		values := readFile(inputFile)

		infos[i] = inputInfo{
			Timestamp:    time.Now(),
			FileName:     fmt.Sprintf("input/%v/input.txt", inputDir.Name()),
			VariableName: inputDir.Name(),
			Values:       values,
		}
	}

	return infos
}

func readFile(inputFile *os.File) []string {

	scanner := bufio.NewScanner(inputFile)

	scanner.Split(bufio.ScanLines)
	var values []string

	for scanner.Scan() {
		values = append(values, scanner.Text())
	}

	return values
}

func generateCodeForInput(infos []inputInfo) {
	inputFile, er1 := os.OpenFile("input.go", os.O_APPEND|os.O_WRONLY, 0644)

	handleError(er1)

	defer inputFile.Close()

	for _, v := range infos {

		f, er := os.Create(fmt.Sprintf("%vValues.go", v.VariableName))
		handleError(er)
		defer f.Close()

		packageTemplate.Execute(f, v)
		inputTemplate.Execute(inputFile, v)
	}
}
