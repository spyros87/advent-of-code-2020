// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates contributors.go. It can be invoked by running
// go generate

package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"strconv"
	"strings"
	"text/template"
	"time"
)

type inputInfo struct {
	Timestamp    time.Time
	FileName     string
	VariableName string
	Values       []string
	ValueType    reflect.Kind
}

var packageTemplateText = `// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from:
// {{ .FileName }}
package input

{{- $type := .ValueType }}

var {{ .VariableName }}Values = []{{ $type }}{
{{- range .Values }}
	{{- if eq $type.String "string" }}
	{{ printf "%q," . }}
	{{- else }}
    {{ printf "%v," . }}
	{{- end }}
{{- end }}
}
`

var packageTemplate = template.Must(template.New("").Funcs(template.FuncMap{"StringsJoin": strings.Join}).Parse(packageTemplateText))

var inputTemplateText = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

func {{ .VariableName | Title }}() []{{ .ValueType }} {
	return {{ .VariableName }}Values
}
`
var inputTemplate = template.Must(template.New("").Funcs(template.FuncMap{"Title": strings.Title}).Parse(inputTemplateText))

func main() {

	inputDirs := listInputDirectory()

	inputInfos := parseInputFiles(inputDirs)

	generateCodeForInput(inputInfos)
}

func listInputDirectory() []os.FileInfo {
	inputDirs, er := ioutil.ReadDir("../../input")
	handleError(er)
	return inputDirs
}

func handleError(er error) {
	if er != nil {
		fmt.Println(er)
		os.Exit(1)
	}
}

func parseInputFiles(inputDirs []os.FileInfo) []inputInfo {
	infos := make([]inputInfo, len(inputDirs))

	for i, inputDir := range inputDirs {

		inputFile, er := os.Open(fmt.Sprintf("../../input/%v/input.txt", inputDir.Name()))

		handleError(er)

		values, valueType := readFile(inputFile)

		infos[i] = inputInfo{
			Timestamp:    time.Now(),
			FileName:     fmt.Sprintf("input/%v/input.txt", inputDir.Name()),
			VariableName: inputDir.Name(),
			Values:       values,
			ValueType:    valueType,
		}
		inputFile.Close()
	}

	return infos
}

func readFile(inputFile *os.File) ([]string, reflect.Kind) {

	scanner := bufio.NewScanner(inputFile)

	scanner.Split(bufio.ScanLines)
	var values []string
	var numeric = false

	for scanner.Scan() {
		text := scanner.Text()

		if _, err := strconv.Atoi(text); err == nil {
			numeric = true
		}
		values = append(values, text)
	}

	return values, inputType(numeric)
}

func inputType(numeric bool) reflect.Kind {
	if numeric {
		return reflect.Int
	}
	return reflect.String
}

func generateCodeForInput(infos []inputInfo) {
	inputFile, er1 := os.OpenFile("input.go", os.O_APPEND|os.O_WRONLY, 0644)

	handleError(er1)

	defer inputFile.Close()

	for _, v := range infos {

		f, er := os.Create(fmt.Sprintf("%vValues.go", v.VariableName))
		handleError(er)

		packageTemplate.Execute(f, v)
		inputTemplate.Execute(inputFile, v)
		f.Close()
	}
}
